package function

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"CodeGenerator/util"

	"github.com/iancoleman/strcase"
)

//var serverFunc = make([]*Function, 0)
//var clientFunc = make([]*Function, 0)
//var gate2ClientFuncs = make([]*Function, 0)

func Parse(path string) []*Function {

	fns := make([]*Function, 0)
	file, _ := os.Open(path)

	defer file.Close()
	scanner := bufio.NewScanner(file)

	var count int
	builder := strings.Builder{}
	for scanner.Scan() {
		count++

		// 读取当前行内容
		line := scanner.Text()
		if len(line) == 0 {
			continue
		}

		//fmt.Printf("%d %s\n", count, line)
		if strings.HasPrefix(line, "//") {
			builder.WriteString(line)

		} else {
			fn := NewFunction()
			re := regexp.MustCompile(`\S+\([^)]+\)|\S+`)
			arr := make([]string, 0)
			for _, match := range re.FindAllString(line, -1) {
				arr = append(arr, match)
			}

			fn.Comment = builder.String()
			builder.Reset()

			fn.Sig = strings.TrimRight(arr[4], ";")
			fn.RetType = arr[1]

			var re1 = regexp.MustCompile(`(?m)(\w+\.\w+)|(\w+)`)
			var str1 = arr[2]

			fn.FuncName = re1.FindAllString(str1, -1)[0]
			fn.Agrs = re1.FindAllString(str1, -1)[1]
			fn.Kind = re1.FindAllString(str1, -1)[2]

			switch arr[0] {
			case "CL", "CL_ASYNC":
				fn.Direction = Direction_Client2GameServer
				if arr[0] == "CL_ASYNC" {
					fn.Async = true
					if len(arr) < 5 {
						panic("id:" + fn.Sig + "  函数名:" + fn.FuncName + "-异步函数需要设置的push函数名")
					}
					fn.AsyncOutFuncName = arr[5]
				}
			case "LC":
				fn.Direction = Direction_GameServer2Client
			case "SS":
				fn.Direction = Direction_Server2Server
			case "CS":
				fn.Direction = Direction_Client2Server
			case "SC":
				fn.Direction = Direction_Server2Client
			default:
				fn.Direction = Direction_Unknow
			}

			fmt.Printf("%+v", fn)
			fmt.Println()
			fns = append(fns, fn)
		}

	}
	return fns
}

//func SortByDirection(fns []*Function) {
//	for _, fn := range fns {
//		switch fn.Direction {
//		case "Client2GameServer":
//			serverFunc = append(serverFunc, fn)
//		case "GameServer2Client":
//			clientFunc = append(clientFunc, fn)
//		case "Server2Client":
//			clientFunc = append(clientFunc, fn)
//			gate2ClientFuncs = append(gate2ClientFuncs, fn)
//
//		}
//	}
//}

func GenerateServerInterfaceHeader(writer *bytes.Buffer) {
	writer.WriteString("// Generated by the rpc compiler.  DO NOT EDIT!\n")
	writer.WriteString("\n")
	writer.WriteString("package easyrpc\n")
	writer.WriteString(`import (
		"war/logic/user"
		"war/protos/out/cl"
	)`)
	writer.WriteString("\n")

}

func GenerateServerInterface(writer *bytes.Buffer, fileName string, fns []*Function) {
	writer.WriteString("\n")
	writer.WriteString(fmt.Sprintf("//RPCService%s RPCService%s\n", strcase.ToCamel(fileName), strcase.ToCamel(fileName)))
	writer.WriteString(fmt.Sprintf("type RPCService%s interface {\n", strcase.ToCamel(fileName)))

	for _, fn := range fns {

		if fn.Direction != Direction_Client2GameServer {
			continue
		}
		writer.WriteString("\n")
		writer.WriteString(fmt.Sprintf("\t//%s %s\n", fn.FuncName, fn.Comment))
		writer.WriteString(fmt.Sprintf("\t%s(sender *user.User, in *%s) ", fn.FuncName, fn.Agrs))
		if fn.RetType != "void" && !fn.Async {
			writer.WriteString(fmt.Sprintf("(out *%s)", fn.RetType))
		}
		writer.WriteString("\n")
	}
	writer.WriteString("\n}\n")

}

func GenerateServerInterfaceImplHeader(builder *bytes.Buffer) {

	builder.WriteString(`// Generated by the rpc compiler.  DO NOT EDIT!

package easyrpc

import (
	"fmt"

	"war/protos/out/cl"
	"war/protos/out/ret"

	"github.com/golang/protobuf/proto"
)`)
	builder.WriteString("\n")

}

func GenerateServerInterfaceImpl(builder *bytes.Buffer, fileName string, fns []*Function) {

	builder.WriteString("\n")
	builder.WriteString(fmt.Sprintf("//Register%sService Register%sService\nfunc Register%sService(service RPCService%s) {\n", strcase.ToCamel(fileName), strcase.ToCamel(fileName), strcase.ToCamel(fileName), strcase.ToCamel(fileName)))
	for _, fn := range fns {
		if fn.Direction != Direction_Client2GameServer {
			continue
		}
		builder.WriteString(fmt.Sprintf("\t//%s %s\n", fn.FuncName, fn.Comment))
		builder.WriteString(fmt.Sprintf("\tdispatcherMap[%s] = func(uid uint64, cmd uint32, b []byte) error {\n", fn.Sig))
		builder.WriteString("\t\tsender := getSender(uid)\n")
		builder.WriteString("\t\tif nil == sender {\n")
		builder.WriteString("\t\t\treturn fmt.Errorf(\"no found user =%d, cmd =%d\", uid, cmd)\n")
		builder.WriteString("\t\t}\n\n")
		builder.WriteString("\t\tplayer := sender.GetPlayer()\n")
		builder.WriteString("\t\tif nil == player {\n")
		builder.WriteString("\t\t\treturn fmt.Errorf(\"no found player =%d, cmd =%d\", uid, cmd)\n")
		builder.WriteString("\t\t}\n\n")
		builder.WriteString("\t\t" + "in := &" + fn.Agrs + "{}\n")
		builder.WriteString("\t\t" + "err := proto.Unmarshal(b, in)\n")
		builder.WriteString("\t\t" + "if err != nil {\n")
		builder.WriteString("\t\t\t" + "return fmt.Errorf(\"" + fn.Agrs + " Unmarshal error: %s\", err.Error())\n")
		builder.WriteString("\t\t" + "}\n\n")
		builder.WriteString("\t\t" + "caches, has := sender.GetMsgCache(in.GetSn(), cmd)\n")
		builder.WriteString("\t\t" + "if has {\n")
		builder.WriteString("\t\t\t" + "if caches != nil {\n")
		builder.WriteString("\t\t\t\t" + "sender.ReSendReqCacheMsgToGateway(cmd, caches)\n")
		builder.WriteString("\t\t\t" + "} else {\n")
		builder.WriteString("\t\t\t\t" + "//消息可能在异步处理中，还没有结果，抛弃掉此重复请求\n")
		builder.WriteString(fmt.Sprintf("\t\t\t\tsender.NotifyUntreatedMsg(%s, in.GetSn())\n", fn.Sig))
		builder.WriteString("\t\t\t" + "}\n")
		builder.WriteString("\t\t\t" + "return nil\n")
		builder.WriteString("\t\t" + "}\n")

		builder.WriteString(fmt.Sprintf("\t\tif _, ok := BlackRpcList[%s]; ok {\n", fn.Sig))
		builder.WriteString("\t\t\t" + "out := &" + fn.GetRealRetType() + "{Sn: proto.Int32(in.GetSn()), Code: ret.RET_RPC_IN_BLACK_LIST.Enum()}\n")
		builder.WriteString("\t\t\t" + "out.Code = ret.RET_RPC_IN_BLACK_LIST.Enum()\n")
		builder.WriteString(fmt.Sprintf("\t\t\t_ = sender.PushCmdToGateway(%s, out, out.Sn, %s)\n", fn.Sig, fn.GetIsNotifyStr()))
		builder.WriteString("\t\t\t" + "return nil\n")
		builder.WriteString("\t\t" + "}\n")

		builder.WriteString("\t\t" + "sender.AddMsgHolder(in.GetSn(), cmd)\n")
		builder.WriteString("\t\t" + "sender.SaveGuideTrigger(in.GetGuide(), in.GetTrigger())\n\n")

		str := "\t\t"
		if fn.RetType != "void" && !fn.Async {
			str += "ret := "
		}
		str += fmt.Sprintf("service.%s(sender, in)\n", fn.FuncName)
		builder.WriteString(str)
		if fn.RetType != "void" && !fn.Async {
			builder.WriteString("\t\tret.Result = player.GetRPCResultAndClean()\n")
			builder.WriteString("\t\tret.Sn = in.Sn\n")
			builder.WriteString("\t\tif err := sender.PushCmdToGateway(cmd, ret, in.Sn, false); err != nil {\n")
			builder.WriteString("\t\t\treturn fmt.Errorf(\" + current.Args[0].Typeret Marshal error: %s\", err.Error())\n")
			builder.WriteString("\t\t}\n")

		}
		builder.WriteString("\t\treturn nil\n")
		builder.WriteString("\t}\n")

	}
	builder.WriteString("}\n")
}

func GeneratePlayerClientProxy(path string, fns []*Function) {
	builder := &bytes.Buffer{}
	builder.WriteString(`// Generated by the rpc compiler.  DO NOT EDIT!

package player

import (
	"war/protos/out/cl"
)
`)
	builder.WriteString("\n")
	builder.WriteString("// IClientProxy IClientProxy\ntype IClientProxy interface {\n")
	for _, fn := range fns {
		if fn.Direction != Direction_GameServer2Client && !fn.Async {
			continue
		}
		builder.WriteString("\n")
		builder.WriteString(fmt.Sprintf("\t// %s %s\n", fn.GetOutFuncName(), fn.Comment))
		builder.WriteString(fmt.Sprintf("\t%s(msg *%s)\n", fn.GetOutFuncName(), fn.GetRealRetType()))

	}
	builder.WriteString("}\n")
	ioutil.WriteFile(path, builder.Bytes(), os.ModeAppend|os.FileMode(0664))
}

func GenerateUserSenderHeader(builder *bytes.Buffer) {
	builder.WriteString(`// Generated by the rpc compiler.  DO NOT EDIT!

package user

import (
	"war/protos/out/cl"
	"github.com/golang/protobuf/proto"
)`)
	builder.WriteString("\n")
}

func GenerateUserSender(builder *bytes.Buffer, fns []*Function) {

	for _, fn := range fns {
		if fn.Direction != Direction_GameServer2Client && !fn.Async {
			continue
		}
		builder.WriteString("\n")
		comment := fn.Comment
		if comment == "" {
			comment = fn.FuncName
		}

		builder.WriteString(fmt.Sprintf("// %s %s\n", fn.GetOutFuncName(), fn.Comment))
		builder.WriteString("//param sendResult - 发送给客户端Result\n")

		builder.WriteString(fmt.Sprintf("func (u *User) %s(msg *%s) {\n", fn.GetOutFuncName(), fn.GetRealRetType()))

		if fn.Direction == Direction_Client2GameServer {
			builder.WriteString("\tmsg.Result = u.GetPlayer().GetRPCResultAndClean()\n")
			builder.WriteString(fmt.Sprintf("\t_ = u.PushCmdToGateway(%s, msg, msg.Sn, %t)\n", fn.Sig, false))
			builder.WriteString("}\n")
		} else {
			builder.WriteString("\tif msg.Sn == nil {\n")
			builder.WriteString("\t\tmsg.Sn = proto.Int32(0)\n")
			builder.WriteString("\t}\n")
			builder.WriteString(fmt.Sprintf("\t_ = u.PushCmdToGateway(%s, msg, msg.Sn, %t)\n", fn.Sig, true))
			builder.WriteString("}\n")
		}

	}

}

func GenerateRobotInterface(fileName string, fns []*Function) {

	writer := bytes.Buffer{}
	writer.WriteString(`// Generated by the rpc compiler.  DO NOT EDIT!

package robot

import (

	"war/protos/out/cl"

)`)
	writer.WriteString("\n")
	writer.WriteString("type RPCService interface {\n\n")

	for _, fn := range fns {
		writer.WriteString(fmt.Sprintf("\t//%s %s\n", fn.FuncName, fn.Comment))
		writer.WriteString(fmt.Sprintf("\t%s(msg *%s)\n\n", fn.FuncName, fn.GetRealRetType()))
	}
	writer.WriteString("}\n")

	ioutil.WriteFile(fileName, writer.Bytes(), os.ModeAppend|os.FileMode(0664))

}

func GenerateRobotInterfaceImpl(fileName string, fns []*Function) {
	builder := bytes.Buffer{}
	builder.WriteString(`// Generated by the rpc compiler.  DO NOT EDIT!

package robot

import (
	"fmt"

	"war/protos/out/cl"

	"github.com/golang/protobuf/proto"
)`)
	builder.WriteString("\n\n")
	builder.WriteString("func (dispatcher *RpcDispatcher) Dispatch(cmd uint32, b []byte) (bool, error) {\n\tswitch cmd {\n")
	for _, fn := range fns {
		builder.WriteString(fmt.Sprintf("\tcase %s:\n\t\t{\n\t\t\t//%s %s\n", fn.Sig, fn.FuncName, fn.Comment))
		builder.WriteString(fmt.Sprintf("\t\t\tin := &%s{}\n", fn.GetRealRetType()))
		builder.WriteString("\t\t\t" + "err := proto.Unmarshal(b, in)\n")
		builder.WriteString("\t\t\t" + "if err != nil {\n")
		builder.WriteString("\t\t\t\t" + "return true, fmt.Errorf(\"" + fn.GetRealRetType() + " Unmarshal error: %s\", err.Error())\n")
		builder.WriteString("\t\t\t" + "}\n\n")
		builder.WriteString(fmt.Sprintf("\t\t\tdispatcher.service.%s(in)\n\t\t\treturn true, nil\n\t\t}\n", fn.FuncName))
	}
	builder.WriteString("\t}\n\treturn false, nil\n}\n")
	ioutil.WriteFile(fileName, builder.Bytes(), os.ModeAppend|os.FileMode(0664))
}

func GenerateRobotSessionSender(fileName string, fns []*Function) {

	builder := bytes.Buffer{}
	builder.WriteString(`// Generated by the rpc compiler.  DO NOT EDIT!

package robotsession

import (
	"war/protos/out/cl"
)
`)
	builder.WriteString("\n")
	for _, fn := range fns {
		if fn.Direction != Direction_Client2GameServer {
			continue
		}
		builder.WriteString("\n")
		builder.WriteString(fmt.Sprintf("//%s %s\n", fn.FuncName, fn.Comment))
		builder.WriteString("func (session *RobotSession) " + fn.FuncName + "(msg *" + fn.Agrs + ") {\n")
		builder.WriteString(fmt.Sprintf("\tsession.Send(uint32(%s), msg)\n}\n", fn.Sig))

	}
	fmt.Println(builder.String())
	ioutil.WriteFile(fileName, builder.Bytes(), os.ModeAppend|os.FileMode(0664))
}

func GenerateRobotPacketRpcDef(fileName string, fns []*Function) {
	builder := bytes.Buffer{}
	builder.WriteString(`// Generated by the rpc compiler.  DO NOT EDIT!

package packet

import (
	"war/protos/out/cl"

	"github.com/golang/protobuf/proto"
)`)

	builder.WriteString("\n")
	/*
		builder.WriteString("const (\n")
		for _, fn := range fns {
			if fn.Direction != Direction_Client2GameServer {
				continue
			}

			builder.WriteString(fmt.Sprintf("\t%s uint32 = %s\n", fn.FuncName, fn.Sig))
		}
		builder.WriteString(")\n\n")
		builder.WriteString("var (\n\tRPCMap = map[string]uint32 {\n")
		for _, fn := range fns {
			if fn.Direction != Direction_Client2GameServer {
				continue
			}

			builder.WriteString(fmt.Sprintf("\t\t%s,\n", fmt.Sprintf(`"%s": %s`, fn.FuncName, fn.Sig)))
		}
		builder.WriteString("\t}\n)\n\n")
		builder.WriteString("var (\n\tRPCParam = map[string]proto.Message {\n")
		for _, fn := range fns {
			if fn.Direction != Direction_Client2GameServer {
				continue
			}
			builder.WriteString(fmt.Sprintf("\t\t%s,\n", fmt.Sprintf(`"%s": &%s{}`, fn.FuncName, fn.Agrs)))

		}
		builder.WriteString("\t}\n)\n")
	*/

	builder.WriteString("\n")
	builder.WriteString("// RPC struct\n")
	builder.WriteString(`type RPC struct {
	Name       string
	RequestMsg proto.Message
	RespondMsg proto.Message
}`)

	builder.WriteString("\n\n")
	builder.WriteString("// RPCs map\n")
	builder.WriteString("var (\n\tRPCs = map[uint32]RPC{\n")
	for _, fn := range fns {
		if fn.Direction != Direction_Client2GameServer {
			continue
		}
		builder.WriteString(fmt.Sprintf("\t\t%s: {\n", fn.Sig))
		builder.WriteString(fmt.Sprintf("\t\t\tName:       %s,\n", fmt.Sprintf(`"%s"`, fn.FuncName)))
		builder.WriteString(fmt.Sprintf("\t\t\tRequestMsg: &%s{},\n", fn.Agrs))
		builder.WriteString(fmt.Sprintf("\t\t\tRespondMsg: &%s{},\n", fn.RetType))
		builder.WriteString("\t\t},\n")
	}
	builder.WriteString("\t}\n)\n")

	builder.WriteString("\n")
	builder.WriteString("// RPCNames map\n")
	builder.WriteString("var (\n\tRPCNames = map[string]uint32{\n")
	var maxNameLen int
	for _, fn := range fns {
		if fn.Direction != Direction_Client2GameServer {
			continue
		}
		nameLen := len([]rune(fn.FuncName))
		if nameLen > maxNameLen {
			maxNameLen = nameLen
		}
	}
	for _, fn := range fns {
		if fn.Direction != Direction_Client2GameServer {
			continue
		}
		nameLen := len([]rune(fn.FuncName))
		fmtSpace := bytes.Buffer{}
		for i := 0; i < maxNameLen-nameLen; i++ {
			fmtSpace.WriteString(" ")
		}
		builder.WriteString(fmt.Sprintf("\t\t%s,\n", fmt.Sprintf(`"%s": %s%s`, fn.FuncName, fmtSpace.String(), fn.Sig)))
	}
	builder.WriteString("\t}\n)\n")

	ioutil.WriteFile(fileName, builder.Bytes(), os.ModeAppend|os.FileMode(0664))
}

func GenerateClientSessionPack(fileName string, fns []*Function) {
	builder := bytes.Buffer{}
	builder.WriteString(`// Generated by the rpc compiler.  DO NOT EDIT!

package clientsession

import (
	"war/protos/out/cl"
)`)
	builder.WriteString("\n\n")
	builder.WriteString("func addPack() {\n")
	for _, fn := range fns {
		if fn.Direction == Direction_GameServer2Client {
			builder.WriteString(fmt.Sprintf("\tpackOut[%s] = &%s{}\n", fn.Sig, fn.Agrs))
		} else if fn.Direction == Direction_Client2GameServer {

			builder.WriteString(fmt.Sprintf("\tpackIn[%s] = &%s{}\n", fn.Sig, fn.Agrs))
			if fn.RetType != "void" {

				builder.WriteString(fmt.Sprintf("\tpackOut[%s] = &%s{}\n", fn.Sig, fn.RetType))
			}
		}
	}
	builder.WriteString("}\n")

	ioutil.WriteFile(fileName, builder.Bytes(), os.ModeAppend|os.FileMode(0664))
}

func GenerateProtoLua(protoDir, outDir string) error {

	fileNames, err := util.DirNames(protoDir)
	if err != nil {

		return err
	}
	for _, v := range fileNames {

		if !strings.HasSuffix(v, ".proto") {
			continue
		}

		lines := []string{"return [========["}
		lines1, _ := util.ReadLines(filepath.Join(protoDir, v))
		lines = append(lines, lines1...)

		for i := 0; i < len(lines); i++ {
			if strings.Contains(lines[i], "syntax") {

				lines[i] = ""
			}

			if strings.Contains(lines[i], "import") {
				lines[i] = ""
			}

			all := strings.ReplaceAll(lines[i], "[jstype = JS_STRING]", "")
			lines[i] = all
		}

		lines = append(lines, "")
		lines = append(lines, "]========]")
		luaName := strings.Replace(v, ".proto", ".lua", -1)

		ioutil.WriteFile(filepath.Join(outDir, luaName), []byte(strings.Join(lines, "\n")), os.ModeExclusive|os.FileMode(0664))

	}

	return nil
}

func GenerateLuaTable(hFileDir, path string) error {

	fileNames, err := util.DirNames(hFileDir)
	if err != nil {
		return err
	}
	funcs := make([]*Function, 0)
	sort.Strings(fileNames)
	funcMap := make(map[string][]*Function, 0)
	for _, name := range fileNames {
		if strings.HasSuffix(name, ".h") {

			parse := Parse(filepath.Join(hFileDir, name))

			funcMap[name] = parse
			funcs = append(funcs, parse...)
		}

	}

	buffer := &bytes.Buffer{}
	buffer.WriteString("--Generated by the rpc compiler.  DO NOT EDIT!\n\n")
	buffer.WriteString("local networkDataRules = {\n\td = {\n")

	keys := make([]string, 0, len(funcMap))
	for k := range funcMap {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		buffer.WriteString("\n")
		buffer.WriteString("\t\t--" + k)
		buffer.WriteString("\n")
		for _, fn := range funcMap[k] {
			inStr := ""
			outStr := ""
			if fn.Direction == Direction_Client2GameServer {
				inStr = fn.Agrs
				outStr = fn.RetType
			} else if fn.Direction == Direction_GameServer2Client {
				outStr = fn.Agrs
			} else {
				continue
			}
			buffer.WriteString(fmt.Sprintf("\t\t--%s\n", fn.Comment))
			line := fmt.Sprintf("\t\t[%s] = { \"%s\", \"%s\", \"%s\" },\n\n", fn.Sig, fn.FuncName, inStr, outStr)
			buffer.WriteString(line)

		}

	}

	buffer.WriteString("\n\t},\n")

	buffer.WriteString("\tk = {\n")

	for _, fn := range funcs {
		buffer.WriteString(fmt.Sprintf("\t\t %s = %s ,\n", fn.FuncName, fn.Sig))
	}
	buffer.WriteString("\t},\n")
	buffer.WriteString("} return networkDataRules\n")

	ioutil.WriteFile(path, buffer.Bytes(), os.ModeExclusive|os.FileMode(0664))
	return nil

}
